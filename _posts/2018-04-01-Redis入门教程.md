---
layout: post
title: Redis入门教程
subtitle: NoSQL、Redis、环境安装、Jedis
date: 2018-04-01
categories: Redis
tags: [Redis]
description: Redis入门_上。
---

> NoSQL概述——not only sql 泛指非关系性数据库

```Java
nosql非关系数据库（redis  mongodb）

优点：

去掉了关系数据库的"关系特性"  易扩展  

有非常高的读写性能 尤其在大数据量下

灵活的数据模型（无需提前简历字段）

高可用

缺点:

没有统一的标准  层出不穷

四大分类：

一、键值对存储 Key-Value  =>redis

优势：查找速度比较快

劣势：存储数据缺少结构化

二、列存储 =>HBase

优势：查找速度比较快 扩展性强

劣势：功能比较局限性

三、文档数据库  =>MongoDB

优势：数据结构要求不严格

劣势：查询性能不是特别的高 

四、图形数据库 =>应用于社交网络的数据库

优势：图结构的算法

劣势：不容易分布式集群方案

```

> Redis概述

```Java
Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、
Key-Value数据库，并提供多种语言的API。

应用场景：

1.缓存

2.聊天室，秒杀，任务队列（list结构，pop(弹出),push（插入））

3.数据存储（add,del,update,select）定期持久化到硬盘中

4.网站统计

5.数据过期处理

6.分布式集群架构中的session分离
```

> 环境安装——windows

下载链接：https://pan.baidu.com/s/14kXQwUAHkVKIdXmS05MQFw 密码：0fy6

windows下的安装很简单，只需要一路下一步即可 (￣▽￣)~* 

> 环境安装——centos7

这里我已经搭建好了Centos7虚拟机环境！

- 1.yum安装gcc依赖

```Java
# yum install gcc
```
- 2.下载redis安装包并解压

```Java
# wget http://download.redis.io/releases/redis-4.0.6.tar.gz
# tar -zxvf redis-4.0.6.tar.gz
```
- 3.跳转到redis解压目录，编译安装

```Java
# cd redis-4.0.6
# make
# make install
```
*Redis没有其他外部依赖，安装过程很简单。编译后在Redis源代码目录的src文件夹中可以找到若干个可执行程序，安装完后，在/usr/local/bin目录中可以找到刚刚安装的redis可执行文件。*

![image](http://cnsyear.com/images/blog/TIM截图20180401210355.png?1)

```Java
redis-server：Redis服务器端启动程序
redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作 
redis-benchmark：Redis性能测试工具 
redis-check-aof：数据修复工具 
redis-check-dump：检查导出工具
```
- 启动Redis

直接运行redis-server即可启动Redis

```Java
# redis-server
```
![image](http://cnsyear.com/images/blog/TIM截图20180401210714.png?1)

如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便，按 ctrl + c可以关闭窗口。

以后台进程方式启动redis

第一步：修改redis-4.0.6/redis.conf文件

```Java
# vim /redis-4.0.6/redis.conf  ----每个人的路径不同

将
daemonize no　　
修改为
daemonize yes

小技巧：/daemonize 快速向下查找 ?daemonize 快速向上查找

# wq
```

第二步：指定redis.conf文件启动

```Java
# cp redis.conf /etc 
# redis-server /etc/redis.conf

15831:C 01 Apr 21:18:53.728 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
15831:C 01 Apr 21:18:53.728 # Redis version=4.0.6, bits=64, commit=00000000, modified=0, pid=15831, just started
15831:C 01 Apr 21:18:53.728 # Configuration loaded

```

第四步：检查是否启动成功

```Java
# ps -ef|grep redis
root     15832     1  0 21:18 ?        00:00:00 redis-server 127.0.0.1:6379
root     15840 12339  0 21:19 pts/0    00:00:00 grep --color=auto redis
```
Redis服务端默认连接端口是6379.

第五步：客户端登录

```Java
# redis-cli
127.0.0.1:6379> set zhaojie '一个有梦想的Boy'
OK
127.0.0.1:6379> get zhaojie
"\xe4\xb8\x80\xe4\xb8\xaa\xe6\x9c\x89\xe6\xa2\xa6\xe6\x83\xb3\xe7\x9a\x84Boy"
127.0.0.1:6379> quit
```

第六步：关闭redis

```Java
使用kill命令杀死进程---不推荐
# kill -9 15832

使用redis-cli 关闭
# redis-cli shutdown
```

> Jedis入门

使用Java操作Redis需要jedis-2.1.0.jar > [传送门](http://mvnrepository.com/artifact/redis.clients/jedis)

如果需要使用Redis连接池的话，还需commons-pool-1.5.4.jar > [传送门](http://mvnrepository.com/artifact/org.apache.commons/commons-pool2)

```Java
package redis;

import org.junit.Test;

/**
 * Jedis测试
 * @author jiebaobao
 *
 */
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

public class TestRedis {
	/**
	 * 测试连接
	 */
	@Test
	public void testConn() {
		// 获取jedis对象 设置ip和端口号
		Jedis jedis = new Jedis("192.168.2.102", 6379);
		System.out.println("连接成功。。。");
		jedis.set("test", "Hello Jedis!");
		String test = jedis.get("test");
		System.out.println(test);
	}
	
	/**
	 * 测试连接池
	 */
	@Test
	public void testPool() {
		// 获取连接池的配置对象
		JedisPoolConfig conf = new JedisPoolConfig();
		// 设置最大连接数
		conf.setMaxTotal(100);
		// 设置最大空闲连接数
		conf.setMaxIdle(10);
		JedisPool jedisPool = new JedisPool(conf, "192.168.2.102", 6379);
		//获取核心对象
		Jedis jedis = null;
		try {
			jedis = jedisPool.getResource();
			jedis.set("test1", "Hello JedisPool!");
			
			String str = jedis.get("test1");
			System.out.println(str);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if(jedis!=null) {
				jedis.close();
			}
		}
	}
}
```
可能出现的问题> 有时候连接不上可能是因为centos自己带的iptable不让你访问。

[原文链接1](https://www.cnblogs.com/zuidongfeng/p/8032505.html)
[原文链接2](https://blog.csdn.net/baidu_30000217/article/details/51476712)


> Redis的数据结构

- 字符串（String）
    - 二进制的，存入和读取的数据相同
    - value最大长度是512M
    - 命令： 赋值、取值、删除、数值递减、扩展命令
    
```Java
set key value # 赋值
get key # 获取值
getset company baidu ==>  get company , set company baidu
del key # 删除
incr num # num 的值+1 没有默认为0 加一就是1 如果num类型不能做加一运算 报错
decr num # 减一 同理
incrby num 5 # num += 5
decrby num 5 # num -= 5;
append num 5 # num 后面追加字符串“5”如果num不存在默认为空字符串
```

- 哈希（hash）
    - 相当于map,键值对
    - 每一个Hash可以存储4294967295个键值对
    - 操作有 hset hdel hkeys hvalues...

```Java
存储k/v : hset key  k v
取k对应的v: hget key k
删除键k:hdel key k
删除hash:del key
存储多个k/v对: hmset key k1 v1 k2 v2 ... kn vn
取多个k对应的值: hmget key k1 k2 ... kn
取所有的k/v对: hgetall
取所有键名:hkeys key
取所有的键的值:hvals key
取键值对的个数:hlen key
判断是否存在k:hexists key k  #存在1 不存在0
增加数字:对k加上一个增量(可以为负): hincrby key k delta
对k加上一个浮点数(可以为负): hincrbyfloat key k delta
```

- 字符串列表（list）
    - Redis列表是简单的字符串列表，按照插入顺序排序。
    
```Java
lpush   [listname] [value1] [value2]#列表左端加入值
lpushx   [listname] [value1] [value2]#列表[listname]存在、则在左端加入值
rpush   [listname] [value1] [value2]#列表右端加入值
rpushx   [listname] [value1] [value2]#列表[listname]存在、则在右端加入值
lrange  [listname] [start]  [stop]  #获取区间内的值
lpop  [listname] #弹出最左端值
rpop  [listname] #弹出最右端值
llen [listname] #获取列表长度
lrem [listname] [count] [value] #删除count个指定值，count=0删除所有，
#count>0从左至右删除count个值，count<0从右至左删除count个值
lset [listname] [index] [value] #设置相应index的值 0：第一个，-1：最后一个
linsert [listname] [before/after] [keyvalue] [value] #在第一个[keyvalue]的[之前/之后]插入[value]
rpoplpush [listname1] [listname2] #将[listname1]最右端的值弹出压入[listname2]最左端 
```

- 字符串集合（set）
    -  Redis 的 Set 是 String 类型的无序集合。
    -  Set集合中不能存在重复的元素

```Java
sadd [setname] [value1][value2].. 添加值、从左端添加
srem [setname] [value1][value2].. 删除值
smember  [setname] 查看set集合
sismember [setname] [value] 判断值是否存在 返回1存在；0不存在
sdiff [setname1] [setname2] 差集运算，[setname1]多余的、注意顺序
sinter [setname1] [setname2] 交集运算
sunion [setname1]  [setname2] 合集运算
scard [setname]集合长度
srandmember [setname] [count]随机生成集合中的count个值,默认1个
sdiffstore [setname] [setname1] [setname2]  差集存入[setanme]
sinterstore [setname][setname1] [setname2]  交集存入[setanme] 
sinterstore [setname]  [setname1] [setname2]  并集存入[setanme] 
```

- 有序字符串集合（sorted set）
    -  Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
有序集合的成员是唯一的,但分数(score)却可以重复。

```Java
zadd key 70(分数) value 80(分数）ls //添加元素
zadd key 90(分数）ls //这个时候不会添加元素 ，会把分数为80的替换掉
zadd key 60(分数)tom //这个时候会添加元素成功
zscore key  value  //获取到分数
zcard key // 获取数量
zrem key value1 value2 ....//删除相应的值
zrange key 0 -1 //获取key值
zrange key 0 -1 withscores//获取key值和分数
zrevrange key 0 -1 withscores//从大到小的排序
zremrangebyrank key 0 4//表示 按范范围删除
zremrangebyscore key 80 100 //表示 从80-100分的分数删除掉
zrangebyscore key 0 100 withscores //表示0到100的分数显示
zrangebyscore key 0 100 withscores limit 0 2//只显示2条
zcount key 80 90//显示80 到90分的个数
```

> Redis的通用命令
 
```Java
keys * #查看所有的key
keys my* #查看所有my开头的key，例如my1,my2，my11111
keys my? #查看my开头的key，例如my1,my2
del key1 key2  #删除key
exists key1  #key是否存在
rename key1 key2  #重命名
expire key1 1000  #设置过期时间，秒
ttl key1  #所剩的超时时间
type key1  #key的类型
```

> Redis的事务

- redis 多数据库 最多有16个数据库 0 -15客户端可指定连接某个数据库 默认为0
- select 0 连接第一个数据库
- move myset 1 将myset号数据库移到1号数据库
- 开启事务会将任务放到queue中，当提交事务时逐个执行
    - 命令：
    - 开启事务：multi
    - 提交事务：exec
    - 回滚事务：discard

```Java
127.0.0.1:6379[1]> set num 1
OK
127.0.0.1:6379[1]> multi #开启事务
OK
127.0.0.1:6379[1]> incr num
QUEUED
127.0.0.1:6379[1]> incr num
QUEUED
127.0.0.1:6379[1]> exec #提交事务
1) (integer) 2
2) (integer) 3
127.0.0.1:6379[1]> get num
"3"
127.0.0.1:6379[1]> multi #开启事务
OK
127.0.0.1:6379[1]> incrby num 10
QUEUED
127.0.0.1:6379[1]> discard #回滚事务 中间的执行无效
OK
127.0.0.1:6379[1]> get num
"3"
```

> Redis的持久化

- 两种持久化方式：
RDB方式
AOF方式

- 持久化使用的方式：
    - 1.RDB方式：
默认支持，在指定的时间间隔内，将内存中的数据集快照写入到磁盘
    - 2.AOF方式：
日志的形式记录服务器处理的每一个操作，服务器启动之初，读取文件，重新构建数据库
    - 3.无持久化
通过配置继用Redis持久化功能，Redis缓存机制
    - 4.同时使用RDB和AOF
    
#### RDB

- 优势：
    - 1.数据库只包含一个文件，通过文件备份策略，定期配置，恢复系统灾难
    - 2.压缩文件转移到其他介质上
    - 3.性能最大化，redis开始持久化时，分叉出进程，由子进程完成持久化的工作
，避免服务器进程执行I/O操作，启动效率高

- 劣势：
    - 1.无法高可用：系统一定在定时持久化之前宕机，数据还没写入，数据已经丢失
    - 2.通过fock分叉子进程完成工作，数据集大的时候，服务器需要停止几百毫秒甚至1秒

- 配置：
    
```Java
cd /usr/local/redis
vim redis.conf
默认：
save 900 1 #每900秒至少1个key变化，持久化一次，到内存一个快照
save 300 10 #每300秒至少10个key变化，往硬盘写一次
save 60 10000 #每60秒至少10000个key变化，写一次
dbfilename dump.rdb #数据的文件名
dir ./ #保存的路径，redis路径下
```
#### AOF

- 优势：
    - 1.带来更高的数据安全性。有三种同步策略。每秒同步、每修改同步、不同步。
    - 2.AOF 文件是一个只进行追加操作的日志文件，因此在写入过程中即使出现宕机现象也不影响之前已经存在的内容。
    - 3.如果日志过大，redis可以启动重写机制。在重写过程中产生的对数据库操作记录会保存在一个新文件中，等到重写完成后再追加到现有的文件中。
    - 4.AOF 文件有序地保存了对数据库执行的所有写入操作

- 劣势：
    - 1.对于相同数量的数据集而言，文件比rdb方式要大。
    - 2.效率比rdb低
    
- 打开aof模式，在redis安装目录下修改 redis.conf
    -  修改appendonly no 改为 appendonly yes Redis的目录下会产生appendonly.aof这个文件,用来保存appendonly的之前的增删改操作
    -  选一种同步策略
    -  appendfsync always 每修改一次就同步到磁盘上  
    -  appendfsync everysec 每秒会向硬盘中同步一次
    -  appendfsync no 不同步到硬盘中
    -  停掉redis  ./bin/redis-cli shutdown 
    -  重启redis  ./bin/redis-server ./redis.conf

[菜鸟教程](http://www.runoob.com/redis/redis-tutorial.html)
[易百教程](https://www.yiibai.com/redis/)

*标记：有些爱，藏在嘴边，挂在心尖，浮生若梦，情如流水，爱似桃花……
——唐七 《三生三世 十里桃花》*